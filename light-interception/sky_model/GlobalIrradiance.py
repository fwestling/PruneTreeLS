import WeatherParser
import datetime
import math
import sys

class GlobalIrradiance(object):
	"""
	Returns the global irradiance measurement (W/m^2) from the farm by first looking if measurements 
	from the weather station if the farm is available. If not, a daily measurement is retrieved from 
	BOM (Austrailan Bureau of Meteorology) and that is used to estimate the irradiance for the requested 
	time of day
	"""

	def __init__(self,weather_data_path,BOM_parser):
		self.weather_data = WeatherParser.parseWeatherFile(weather_data_path) # Uncomment to use Vantage Pro data
		self.BOMparser = BOM_parser
		self.farm_utc_offset=10

	def get(self,date,latitude,longitude,utc_offset,verbose=False):
		time_offset=self.farm_utc_offset - utc_offset

		date = date + datetime.timedelta(hours=time_offset)

		date_str = date.strftime('%Y%m%d')
		time_str = date.time().strftime('%H:%M')
		# global_irradiance = self.__getSkyBOM(date,latitude,longitude) # Comment out to use Vantage Pro data
		global_irradiance =''
		# Uncomment to use Vantage Pro data ###
		try:
			## If not a multiple of 30 minutes, interpolate between two nearest multiples of 30 minutes
			mins = time_str.split(':')[1]
			if ( mins != "30" and mins != "00" ):
				hrs = time_str.split(':')[0]
				atime=hrs+":00"
				btime=hrs+":30"
				if int(mins) > 30:
					atime=hrs+":30"
					btime=str(int(hrs)+1)+":00"
				irr_a = self.weather_data[date_str][atime]['SolarRad.']
				irr_b = self.weather_data[date_str][btime]['SolarRad.']
				if (irr_a == '---' or irr_b == '---'):
					global_irradiance = '---'
				else:
					# Calculate global irradiance;
					global_irradiance = str(float(irr_a) + (int(mins)-int(atime.split(':')[1]))*(float(irr_b)-float(irr_a))/30)
			else:
				global_irradiance = self.weather_data[date_str][time_str]['SolarRad.']
			# global_irradiance = self.weather_data[date_str][time_str]['SolarRad.']

			if(global_irradiance == '---'): #No data available
				if verbose:
					sys.stderr.write('Warning: no irradiance data at %s, using BOM\n' %(date))
				global_irradiance = self.__getSkyBOM(date,latitude,longitude)
			else:
				global_irradiance = float(global_irradiance)
		except KeyError:
			if verbose:
				sys.stderr.write('Warning: datetime %s not available, using BOM\n' %(date))
			global_irradiance = self.__getSkyBOM(date,latitude,longitude)
		#########################################

		return global_irradiance


	def __fittedSin(self,height,start,end,x):
		"""
		Fits a sin lobe so it starts at <start> has peak value <height> and ends at <end>. 

		:return: sinlobe(x), if <x> is inside sin lobe, 0 otherwise
		"""

		sin = height*math.sin(math.pi*(x-start)/(end-start))
		if(sin < 0):
			sin = 0
		return sin

	def __getSkyBOM(self,date_time,latitude,longitude):
		"""
		:return: 	estimated irradiance at <date_time> by using statistics of how the irradiance over a day
					of an average day of the month changes compared to daily BOM data

		Constant <Month statistics> holds the shape of a sin lobe [height,start,end], for each month of the year. 
		Data was generated by running WeatherStatisticsGenerator.py for 2015
		"""

		MONTH_STATISTICS = \
		[[38.7, 5.5, 18.5], [38.2, 6.0, 18.5], [40.2, 6.5, 18.0], [40.0, 6.5, 17.5], [43.4, 6.5, 17.5], [43.1, 7.0, 17.0], \
		[43.1, 7.0, 17.0], [43.6, 7.0, 17.5], [37.4, 6.0, 18.0], [36.3, 5.5, 18.0], [36.3, 5.5, 18.0], [35.5, 5.0, 18.5]]

		month = date_time.month
		time = date_time.time().hour + date_time.time().minute/float(60)

		BOM_data = self.BOMparser.solarRadFromBOM(date_time,latitude,longitude)

		sin_coeff = MONTH_STATISTICS[month-1]
		BOM_factor = self.__fittedSin(sin_coeff[0],sin_coeff[1],sin_coeff[2],time)

		return BOM_factor*BOM_data
